#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
/* A lexical scanner generated by flex */

#include "skeleton.h"

# line 1 "ibml.flx"
#define INITIAL 0
# line 2 "ibml.flx"
#include "ibml.h"
#include <string.h>

int  lineindx, discntindx, initindx, elindx;
char *StrVal;
char *lines[256], *discounts [256], *inits[256], *els[256];
char ThisLine[256];
extern int yylval;
extern int TestCnt;

#define indata 2
#define incode 4
#define instring 6
#define discount 8
#define init 10
#define eachloop 12
# line 15 "ibml.flx"
#define YY_JAM 171
#define YY_JAM_BASE 256
#define YY_TEMPLATE 172
static char l[172] =
    {   0,
       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
       -2,   -2,   -2,   -2,   28,    1,    1,   25,   24,   28,
       28,   29,    4,   29,   29,   20,   29,   27,   29,   26,
       29,   17,   29,   29,   10,   29,   29,   14,   29,    1,
       24,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        4,    0,    0,   20,    0,   27,    0,   17,    0,    0,
       10,    0,    0,    0,   14,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   23,    0,    0,    0,    0,
       18,    0,    0,    0,    0,    0,   16,    0,    0,    7,

        0,    0,    0,   12,    5,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    2,    0,    0,
        0,    0,    0,    6,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   22,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    3,    0,   19,    0,    0,    0,    0,    0,   15,
        0,   11,    0,    8,    0,    9,    0,   13,    0,   21,
        0
    } ;

static char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    6,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    1,    1,    1,
        1,    1,    1,    1,    8,    1,    9,   10,   11,    1,
        1,   12,   13,    1,    1,   14,    1,   15,   16,   17,
        1,   18,   19,   20,   21,   22,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    8,    1,    9,   10,

       11,    1,    1,   12,   13,    1,    1,   14,    1,   15,
       16,   17,    1,   18,   19,   20,   21,   22,    1,    1,
        1,    1,    1,    1,    1,    1,    1
    } ;

static char m[23] =
    {   0,
        1,    1,    2,    2,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1
    } ;

static short int b[198] =
    {   0,
        0,    6,   11,   12,  253,   15,    2,   18,  252,   20,
      251,   21,  250,   22,  256,   27,   29,  256,  245,   24,
       26,  248,  256,   35,  247,  256,   37,    0,  256,  256,
      246,  256,   40,  245,  256,   41,  244,  256,   44,   53,
      239,  229,  236,  228,  231,  226,   44,  232,  224,  235,
      256,   38,  234,  256,   46,    0,  233,  256,   55,  232,
      256,   56,   59,  231,  256,   60,  223,  212,  221,  213,
      211,  209,  224,  217,  212,   65,   67,  221,   61,  220,
       75,   62,  219,  210,  212,  256,  208,  210,  208,  213,
      256,  203,  194,   76,   79,  210,  256,   80,  209,  256,

       82,   84,  208,  256,  256,  207,  189,  186,  191,  192,
      202,   87,   88,   89,   93,   94,  201,  256,  190,  191,
      180,  184,  196,  256,   95,   96,   97,   98,   99,  178,
      183,  181,  179,  100,   63,  106,  108,  110,  181,  256,
      173,  175,  188,  187,  109,  113,  114,  173,  185,  184,
      183,  256,  182,  256,  130,  129,  128,  113,  124,  256,
      123,  256,  120,  256,  119,  256,  116,  256,    0,  256,
      256,  134,  136,  138,  140,  142,  144,  146,  148,  150,
        0,  152,  154,  156,  158,  160,  162,  164,  166,  168,
      170,  172,  174,  176,  178,  180,  182

    } ;

static short int d[198] =
    {   0,
      172,  172,  173,  173,  174,  174,  175,  175,  176,  176,
      177,  177,  178,  178,  171,  171,  171,  171,  171,  171,
      171,  179,  171,  179,  180,  171,  180,  181,  171,  171,
      182,  171,  182,  183,  171,  183,  184,  171,  184,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  179,
      171,  179,  180,  171,  180,  181,  182,  171,  182,  183,
      171,  183,  183,  184,  171,  184,  171,  171,  171,  171,
      171,  171,  185,  171,  171,  179,  180,  186,  183,  187,
      183,  184,  188,  171,  171,  171,  171,  171,  171,  185,
      171,  171,  171,  179,  180,  186,  171,  183,  187,  171,

      183,  184,  188,  171,  171,  189,  171,  171,  171,  171,
      190,  179,  180,  183,  183,  184,  189,  171,  171,  171,
      171,  171,  190,  171,  179,  180,  183,  183,  184,  171,
      171,  171,  171,  179,  180,  183,  183,  184,  171,  171,
      171,  171,  191,  192,  183,  183,  184,  171,  193,  194,
      191,  171,  192,  171,  195,  196,  197,  171,  193,  171,
      194,  171,  195,  171,  196,  171,  197,  171,  171,  171,
    -32767,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171

    } ;

static short int n[279] =
    {   0,
       56,   16,   17,   18,   29,   30,   19,   16,   17,   18,
       20,   21,   19,   23,   23,   24,   24,   26,  170,   27,
       29,   30,   32,   35,   38,   33,   36,   39,   40,   40,
       40,   40,   42,   43,   44,   47,   48,   51,   49,   54,
       51,   45,   58,   61,   46,   52,   65,   55,   54,   59,
       62,   63,   76,   66,   40,   40,   72,   58,   61,   73,
       77,   61,   65,   61,   65,   54,   81,   51,   79,   54,
       78,   80,   82,  144,   94,   83,   95,   61,   51,   98,
      102,   54,   61,  101,   61,  112,   65,  113,  114,   51,
       54,   61,  116,  115,  125,   61,   65,   51,   54,   61,

       61,   65,   51,  126,  127,  135,  128,  143,   61,  129,
       61,   61,   65,  137,  134,   61,   65,  136,  168,  138,
      145,  166,  164,  146,  147,  162,  160,  169,  155,  156,
      168,  166,  164,  157,   15,   15,   22,   22,   25,   25,
       28,   28,   31,   31,   34,   34,   37,   37,   50,   50,
       53,   53,   57,   57,   60,   60,   64,   64,   90,   90,
       96,   96,   99,   99,  103,  103,  117,  117,  123,  123,
      151,  151,  153,  153,  159,  159,  161,  161,  163,  163,
      165,  165,  167,  167,  154,  152,  162,  160,  158,  154,
      152,  150,  149,  148,  142,  141,  140,  139,  124,  133,

      132,  131,  130,  118,  124,  122,  121,  120,  119,  118,
      104,  100,   97,  111,  110,   91,  109,  108,  107,  106,
      105,  104,  100,   97,   93,   92,   91,   89,   88,   87,
       86,   85,   84,   65,   61,   58,   54,   51,   75,   74,
       71,   70,   69,   68,   67,   41,   65,   61,   58,   54,
       51,   41,   38,   35,   32,   26,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171
    } ;

static short int c[279] =
    {   0,
      181,    1,    1,    1,    7,    7,    1,    2,    2,    2,
        2,    2,    2,    3,    4,    3,    4,    6,  169,    6,
        8,    8,   10,   12,   14,   10,   12,   14,   16,   16,
       17,   17,   20,   20,   20,   21,   21,   24,   21,   27,
       52,   20,   33,   36,   20,   24,   39,   27,   55,   33,
       36,   36,   52,   39,   40,   40,   47,   59,   62,   47,
       55,   63,   66,   79,   82,  135,   63,   76,   62,   77,
       59,   62,   66,  135,   76,   66,   77,   81,   94,   79,
       82,   95,   98,   81,  101,   94,  102,   95,   98,  112,
      113,  114,  102,  101,  112,  115,  116,  125,  126,  127,

      128,  129,  134,  113,  114,  126,  115,  134,  136,  116,
      137,  145,  138,  128,  125,  146,  147,  127,  167,  129,
      136,  165,  163,  137,  138,  161,  159,  158,  145,  146,
      157,  156,  155,  147,  172,  172,  173,  173,  174,  174,
      175,  175,  176,  176,  177,  177,  178,  178,  179,  179,
      180,  180,  182,  182,  183,  183,  184,  184,  185,  185,
      186,  186,  187,  187,  188,  188,  189,  189,  190,  190,
      191,  191,  192,  192,  193,  193,  194,  194,  195,  195,
      196,  196,  197,  197,  153,  151,  150,  149,  148,  144,
      143,  142,  141,  139,  133,  132,  131,  130,  123,  122,

      121,  120,  119,  117,  111,  110,  109,  108,  107,  106,
      103,   99,   96,   93,   92,   90,   89,   88,   87,   85,
       84,   83,   80,   78,   75,   74,   73,   72,   71,   70,
       69,   68,   67,   64,   60,   57,   53,   50,   49,   48,
       46,   45,   44,   43,   42,   41,   37,   34,   31,   25,
       22,   19,   13,   11,    9,    5,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin = stdin, *yyout = stdout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;

static char input(void);
static void unput(char c);

char *yytext;
static int yyleng;

/*--------------------------------------------------------------------------*/
/*------------------------- BEGIN LEXICAL ANALYZER -------------------------*/
/*--------------------------------------------------------------------------*/

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif



    if ( yy_init )
	{
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	}

    goto get_next_token;

do_action:

#ifdef FLEX_REJECT_ENABLED
    /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
# line 16 "ibml.flx"
;
	YY_BREAK
case 2:
# line 18 "ibml.flx"
{BEGIN indata;}
	YY_BREAK
case 3:
# line 19 "ibml.flx"
{BEGIN 0;}
	YY_BREAK
case 4:
# line 20 "ibml.flx"
{return dataline;}
	YY_BREAK
case 5:
# line 22 "ibml.flx"
{initindx = elindx = discntindx = lineindx = 0;
			 return code;}
	YY_BREAK
case 6:
# line 25 "ibml.flx"
{BEGIN init;}
	YY_BREAK
case 7:
# line 26 "ibml.flx"
{BEGIN incode;}
	YY_BREAK
case 8:
# line 27 "ibml.flx"
{BEGIN discount;}
	YY_BREAK
case 9:
# line 28 "ibml.flx"
{BEGIN eachloop;}
	YY_BREAK
case 10:
# line 29 "ibml.flx"
{inits [initindx++] = strdup(yytext);}
	YY_BREAK
case 11:
# line 31 "ibml.flx"
{BEGIN eachloop;}
	YY_BREAK
case 12:
# line 32 "ibml.flx"
{BEGIN incode;}
	YY_BREAK
case 13:
# line 33 "ibml.flx"
{BEGIN discount;}
	YY_BREAK
case 14:
# line 34 "ibml.flx"
{els [elindx++] = strdup(yytext);}
	YY_BREAK
case 15:
# line 37 "ibml.flx"
{BEGIN discount;}
	YY_BREAK
case 16:
# line 38 "ibml.flx"
{BEGIN incode;}
	YY_BREAK
case 17:
# line 39 "ibml.flx"
{discounts [discntindx++] = strdup(yytext);}
	YY_BREAK
case 18:
# line 41 "ibml.flx"
{BEGIN incode;}
	YY_BREAK
case 19:
# line 42 "ibml.flx"
{BEGIN 0; return codelines;}
	YY_BREAK
case 20:
# line 43 "ibml.flx"
{lines [lineindx++] = strdup(yytext);}
	YY_BREAK
case 21:
# line 45 "ibml.flx"
return repetitions;
	YY_BREAK
case 22:
# line 46 "ibml.flx"
return unravel;
	YY_BREAK
case 23:
# line 47 "ibml.flx"
return end;
	YY_BREAK
case 24:
# line 49 "ibml.flx"
{yylval = atoi(yytext); return decimal;}
	YY_BREAK
case 25:
# line 50 "ibml.flx"
{BEGIN instring;}
	YY_BREAK
case 26:
# line 51 "ibml.flx"
{BEGIN 0; return string;}
	YY_BREAK
case 27:
# line 52 "ibml.flx"
{StrVal = strdup(yytext);}
	YY_BREAK
case 28:
# line 54 "ibml.flx"
return yytext[0];
	YY_BREAK
case 29:
# line 56 "ibml.flx"
YY_DEFAULT_ACTION;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
			break;
			}
		    }

		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	YY_FATAL_ERROR( "no match in flex scanner - possible NULL in input" );
	}
	}

    /*NOTREACHED*/
    }


static  void unput(char c)
{
 register int i;
 register int yy_buf_pos ;

    YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
	{
    yy_buf_pos = YY_BUF_MAX ;
	for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
	    {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	    }

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
	}

    if ( yy_c_buf_p <= 0 )
	YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] =  c;

    YY_DO_BEFORE_ACTION; /* set up yytext again */

    }


static char input(void)
{
    char c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
	{ /* need more input */
	int yy_n_chars;

	/* we can throw away the entire current buffer */
	if ( yy_saw_eof )
	    {
	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;
	    }

	yy_b_buf_p = 0;
	YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

	if ( yy_n_chars == YY_NULL )
	{
	    yy_saw_eof = 1;

	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;

	    return ( input() );
	}

	yy_c_buf_p = -1;
	yy_e_buf_p = yy_n_chars - 1;
	}

    c = (unsigned char) yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }

/*--------------------------------------------------------------------------*/
/*------------------------- END OF LEXICAL ANALYZER ------------------------*/
/*--------------------------------------------------------------------------*/

# line 56 "ibml.flx"

